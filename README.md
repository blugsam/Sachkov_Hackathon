# Sachkov_Hackathon

Привет! Долго размышляя над темой конкурса, я пришёл к мысли, что раз по условиям мы не работаем с данными и не выполняем какую-то бизнес-задачу, было бы отличной идеей реализовать симуляцию работы склада, у которого мы не участвуем в его жизни, а скорее наблюдаем за ней со стороны, как за аквариумом. Такое метафоричное описание "склад-аквариум" и стало отправной точкой в архитектурном планировании моего приложения - большом эксперименте с возможностями языка C# и консольным форматом вывода, с которым я чаще всего работаю на текущем этапе обучения программированию.

Реализация:
	Как я отметил ранее, главной задачей было не просто реализовать складскую логику, а найти интересный способ применить возможности C#. Я сосредоточился на нестандартном использовании async/await и Task. Вместо классического применения, как в веб разработке, я использовал их для параллельно протекающей симуляции.
	1)Асинхронные Процессы: Каждый основной процесс — генератор поставок, генератор заказов, и каждый из нескольких сборщиков работает как отдельная, независимая асинхронная задача (async Task) в бесконечном цикле.
	2)Моделирование Времени: await Task.Delay() используется как инструмент моделирования времени, имитируя длительность реальных складских операций. Это позволяет задачам выполняться параллельно друг с другом.
	3)Взаимодействие Потоков: Для внедрения многопоточной работы процессов я использовал ConcurrentQueue<T>
	4)Визуализация: Для наблюдения за "аквариумом", я сделал приятный глазу вывод в консоль.
	Также достойны внимания общеархитектурные решения, которые я использовал в разработке.
	1)В методе GetRacks() я реализовал глубокое копирование возвращаемых стоек и их содержимого. 
	2)Вместо передачи полных объектов Item в заказ, я создал специальный ItemKey (внутри ItemDTO), содержащий только необходимую информацию (ID и Тип).
	3)В местах доступа к общим изменяемым данным (например, внутри Rack) применены lock.

Как проект работает:
	При запуске приложение инициализирует структуру склада, затем стартует несколько параллельных задач-сборщиков и две задачи-генератора (поставок и заказов). Генераторы начинают добавлять элементы в очереди, а сборщики постоянно пытаются извлечь задачи (разместить товар или собрать заказ) из этих очередей, выполняя их с имитацией задержки. Весь процесс транслируется в консоль разными цветами для наглядности, пока пользователь не остановит приложение нажатием Ctrl+C.

Что получилось?
	Моей изначальной целью было создать работающую асинхронную симуляцию, демонстрирующую параллельное выполнение складских процессов с помощью async/await и Task. Я хотел, чтобы приложение было "живым" и наглядным через консольный вывод. Эту цель удалось полностью достичь.

Что не получилось?
	1)Изначально была мысль добавить редкие случайные события, вносящие немного хаоса в симуляцию (например, потеря товара, поломка полки, временная недоступность сборщика).
	2)В таком приложении хочется максимизировать статистику о происходящем. В текущей версии у меня не реализован сбор и вывод какой-либо статистики по работе склада (среднее время сборки заказа, загруженность сборщиков, количество обработанных товаров/заказов и т.д.).
	3)Сейчас поиск товара/его места довольно простой. Можно было бы усложнить алгоритмы размещения и поиска товаров на складе.
